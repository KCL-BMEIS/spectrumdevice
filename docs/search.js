window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pyspecde", "modulename": "pyspecde", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pyspecde.SpectrumCard", "modulename": "pyspecde", "qualname": "SpectrumCard", "type": "class", "doc": "<p>Abstract superclass which implements methods of the interface common to all Spectrum digitizer devices.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.__init__", "modulename": "pyspecde", "qualname": "SpectrumCard.__init__", "type": "function", "doc": "<p>Class for controlling individual Spectrum digitizer cards.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>device_number (int):</strong>  Index of the card to control. If only one card is present, set to 0.</li>\n<li><strong>ip_address (Optional[str]):</strong>  If connecting to a networked card, provide the IP address here as a string.</li>\n</ul>\n", "parameters": ["self", "device_number", "ip_address"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.reconnect", "modulename": "pyspecde", "qualname": "SpectrumCard.reconnect", "type": "function", "doc": "<p>Reconnect to the card after disconnect() has been called.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.status", "modulename": "pyspecde", "qualname": "SpectrumCard.status", "type": "variable", "doc": "<p>Read the current acquisition status of the card.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Statuses (CARD_STATUS_TYPE): A list of StatusCode Enums describing the current acquisition status of the\n  card. See settings/status.py (and the Spectrum documentation) for the list off possible\n  acquisition statuses.</p>\n</blockquote>\n"}, {"fullname": "pyspecde.SpectrumCard.wait_for_acquisition_to_complete", "modulename": "pyspecde", "qualname": "SpectrumCard.wait_for_acquisition_to_complete", "type": "function", "doc": "<p>Blocks until the current acquisition has finished, or the timeout is reached.</p>\n\n<p>In Standard Single mode (SPC_REC_STD_SINGLE), this should be called after start_acquisition(). Ones the call\nto wait_for_acquisition_to_complete() returns, the newly acquired samples are in the on_device buffer and ready\nfor transfer to the TransferBuffer using start_transfer().</p>\n\n<p>In FIFO mode (SPC_REC_FIFO_SINGLE, SPC_REC_FIFO_MULTI), the card will continue to acquire samples until\nstop_acquisition() is called, so wait_for_acquisition_to_complete() should not be used.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.start_transfer", "modulename": "pyspecde", "qualname": "SpectrumCard.start_transfer", "type": "function", "doc": "<p>Transfer acquired waveforms from the on-device buffer to the TransferBuffer.</p>\n\n<p>Requires that a TransferBuffer has been defined (see define_transfer_buffer()).</p>\n\n<p>In Standard Single mode (SPC_REC_STD_SINGLE), start_transfer() should be called after each acquisition has\ncompleted.</p>\n\n<p>In FIFO mode (SPC_REC_FIFO_SINGLE, SPC_REC_FIFO_MULTI), start_transfer() should be called immediately after\nstart_acquisition() has been called, so that the waveform data can be continuously streamed into the transfer\nbuffer as it is acquired.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.stop_transfer", "modulename": "pyspecde", "qualname": "SpectrumCard.stop_transfer", "type": "function", "doc": "<p>Stop the transfer of samples from the on-device buffer to the TransferBuffer.</p>\n\n<p>This method is rarely required, and may invalidate transferred samples.</p>\n\n<p>In Standard Single mode (SPC_REC_STD_SINGLE), transfer will automatically stop once all acquired samples have\nbeen transferred, so stop_transfer() should not be used. Instead, call wait_for_transfer_to_complete() after\nstart_transfer().</p>\n\n<p>In FIFO mode (SPC_REC_FIFO_SINGLE, SPC_REC_FIFO_MULTI), samples are transferred continuously during acquisition,\nand transfer will automatically stop when stop_acquisition() is called as there will be no more samples to\ntransfer, so so stop_transfer() should not be used.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.wait_for_transfer_to_complete", "modulename": "pyspecde", "qualname": "SpectrumCard.wait_for_transfer_to_complete", "type": "function", "doc": "<p>Blocks until the currently active transfer of samples from the on-device buffer to the TransferBuffer is\ncomplete.</p>\n\n<p>Used in Standard Single mode (SPC_REC_STD_SINGLE) after starting a transfer. Once the method returns, all\nacquired waveforms have been transferred from the on_device buffer to the TransferBuffer and can be read using\nthe get_waveforms() method.</p>\n\n<p>Not required in FIFO mode (SPC_REC_FIFO_SINGLE, SPC_REC_FIFO_MULTI) because samples are continuously streamed\nuntil stop_acquisition() is called.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.transfer_buffers", "modulename": "pyspecde", "qualname": "SpectrumCard.transfer_buffers", "type": "variable", "doc": "<p>Return the TransferBuffer object containing the latest transferred samples.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>buffer (List[TransferBuffer]): A length-1 list containing the TransferBuffer object. The samples within the\n      TransferBuffer can be accessed using its own interface, but the samples are stored as a 1D array, with\n      the samples of each channel interleaved. It is more convenient to read waveform data using the\n      get_waveforms() method.</p>\n</blockquote>\n"}, {"fullname": "pyspecde.SpectrumCard.define_transfer_buffer", "modulename": "pyspecde", "qualname": "SpectrumCard.define_transfer_buffer", "type": "function", "doc": "<p>Create or provide a CardToPCDataTransferBuffer object for receiving acquired samples from the device.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>buffer (Optional[List[CardToPCDataTransferBuffer]]):</strong>  A length-1 list containing a pre-constructed</li>\n<li>CardToPCDataTransferBuffer  The size of the buffer should be chosen according to the current number of</li>\n<li>active channels and the acquisition length.</li>\n</ul>\n\n<p>If no buffer is provided, one will be created with the correct size and a board_memory_offset_bytes of 0.</p>\n", "parameters": ["self", "buffer"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.get_waveforms", "modulename": "pyspecde", "qualname": "SpectrumCard.get_waveforms", "type": "function", "doc": "<p>Get a list of of the most recently transferred waveforms.</p>\n\n<p>This method copies and reshapes the samples in the TransferBuffer into a list of 1D NumPy arrays (waveforms) and\nreturns the list.</p>\n\n<p>In Standard Single mode (SPC_REC_STD_SINGLE), get_waveforms() should be called after\nwait_for_transfer_to_complete() has returned.</p>\n\n<p>In FIFO mode (SPC_REC_FIFO_SINGLE, SPC_REC_FIFO_MULTI), while the card is continuously acquiring samples and\ntransferring them to the TransferBuffer, this method should be called in a loop . The method will block until\neach new transfer is received, so the loop will run at the same rate as the acquisition (in SPC_REC_FIFO_MULTI\nmode, for example, this would the rate at which your trigger source was running).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>waveforms (List[ndarray]): A list of 1D NumPy arrays, one for each channel enabled for the acquisition,\n      ordered by channel number.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.disconnect", "modulename": "pyspecde", "qualname": "SpectrumCard.disconnect", "type": "function", "doc": "<p>Terminate the connection to the hardware device.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.connected", "modulename": "pyspecde", "qualname": "SpectrumCard.connected", "type": "variable", "doc": "<p>Returns True if a hardware device is currently connected, False if not.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.channels", "modulename": "pyspecde", "qualname": "SpectrumCard.channels", "type": "variable", "doc": "<p>A list of channels belonging to the digitizer card.</p>\n\n<p>Properties of the individual channels (e.g. vertical range) can be set by calling their methods directly.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.enabled_channels", "modulename": "pyspecde", "qualname": "SpectrumCard.enabled_channels", "type": "variable", "doc": "<p>The indices of the currently enabled channels (a list of integers).</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_enabled_channels", "modulename": "pyspecde", "qualname": "SpectrumCard.set_enabled_channels", "type": "function", "doc": "<p>Change which channels are enabled.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>channels_nums (List[int]):</strong>  The integer channel numbers to enable.</li>\n</ul>\n", "parameters": ["self", "channels_nums"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.trigger_sources", "modulename": "pyspecde", "qualname": "SpectrumCard.trigger_sources", "type": "variable", "doc": "<p>The currently enabled trigger sources</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>sources (List[TriggerSource]): A list of TriggerSources.</p>\n</blockquote>\n"}, {"fullname": "pyspecde.SpectrumCard.set_trigger_sources", "modulename": "pyspecde", "qualname": "SpectrumCard.set_trigger_sources", "type": "function", "doc": "<p>Change the enabled trigger sources.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>sources (List[TriggerSources]):</strong>  The TriggerSources to enable.</li>\n</ul>\n", "parameters": ["self", "sources"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.external_trigger_mode", "modulename": "pyspecde", "qualname": "SpectrumCard.external_trigger_mode", "type": "variable", "doc": "<p>The currently enabled external trigger mode. An external trigger source must be enabled.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_external_trigger_mode", "modulename": "pyspecde", "qualname": "SpectrumCard.set_external_trigger_mode", "type": "function", "doc": "<p>Change the currently enabled trigger mode. An external trigger source must be enabled.</p>\n", "parameters": ["self", "mode"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.external_trigger_level_mv", "modulename": "pyspecde", "qualname": "SpectrumCard.external_trigger_level_mv", "type": "variable", "doc": "<p>The signal level (mV) needed to trigger an acquisition using an external trigger source. An external\ntrigger source must be enabled.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_external_trigger_level_mv", "modulename": "pyspecde", "qualname": "SpectrumCard.set_external_trigger_level_mv", "type": "function", "doc": "<p>Change the signal level (mV) needed to trigger an acquisition using an external trigger source. An external\ntrigger source must be enabled.</p>\n", "parameters": ["self", "level"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.external_trigger_pulse_width_in_samples", "modulename": "pyspecde", "qualname": "SpectrumCard.external_trigger_pulse_width_in_samples", "type": "variable", "doc": "<p>The pulse width (samples) needed to trigger an acquisition using an external trigger source if\nSPC_TM_PW_SMALLER or SPC_TM_PW_GREATER ExternalTriggerMode is selected. An external trigger source must be\nenabled.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_external_trigger_pulse_width_in_samples", "modulename": "pyspecde", "qualname": "SpectrumCard.set_external_trigger_pulse_width_in_samples", "type": "function", "doc": "<p>Change the pulse width (samples) needed to trigger an acquisition using an external trigger source if\nSPC_TM_PW_SMALLER or SPC_TM_PW_GREATER ExternalTriggerMode is selected. An external trigger source must be\nenabled.</p>\n", "parameters": ["self", "width"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.apply_channel_enabling", "modulename": "pyspecde", "qualname": "SpectrumCard.apply_channel_enabling", "type": "function", "doc": "<p>Apply the enabled channels chosen using set_enable_channels(). This happens automatically and does not\nusually need to be called.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.acquisition_length_samples", "modulename": "pyspecde", "qualname": "SpectrumCard.acquisition_length_samples", "type": "variable", "doc": "<p>The current recording length (per channel) in samples.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_acquisition_length_samples", "modulename": "pyspecde", "qualname": "SpectrumCard.set_acquisition_length_samples", "type": "function", "doc": "<p>Change the recording length (per channel). In FIFO mode, it will be quantised to nearest 8 samples.</p>\n", "parameters": ["self", "length_in_samples"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.post_trigger_length_samples", "modulename": "pyspecde", "qualname": "SpectrumCard.post_trigger_length_samples", "type": "variable", "doc": "<p>The number of samples of the recording that will contain data received after the trigger event.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_post_trigger_length_samples", "modulename": "pyspecde", "qualname": "SpectrumCard.set_post_trigger_length_samples", "type": "function", "doc": "<p>Change the number of samples of the recording that will contain data received after the trigger event.\nIn FIFO mode, this will be quantised to nearest 8 samples with a maximum value 8 samples less than the acquisition\nlength.</p>\n", "parameters": ["self", "length_in_samples"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.acquisition_mode", "modulename": "pyspecde", "qualname": "SpectrumCard.acquisition_mode", "type": "variable", "doc": "<p>The currently enabled card mode.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_acquisition_mode", "modulename": "pyspecde", "qualname": "SpectrumCard.set_acquisition_mode", "type": "function", "doc": "<p>Change the currently enabled card mode. See AcquisitionMode and the Spectrum documentation\nfor the available modes.</p>\n", "parameters": ["self", "mode"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.timeout_ms", "modulename": "pyspecde", "qualname": "SpectrumCard.timeout_ms", "type": "variable", "doc": "<p>The time for which the card will wait for a trigger to tbe received after an acquisition has started\nbefore returning an error.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_timeout_ms", "modulename": "pyspecde", "qualname": "SpectrumCard.set_timeout_ms", "type": "function", "doc": "<p>Change the time for which the card will wait for a trigger to tbe received after an acquisition has started\nbefore returning an error.</p>\n", "parameters": ["self", "timeout_in_ms"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.clock_mode", "modulename": "pyspecde", "qualname": "SpectrumCard.clock_mode", "type": "variable", "doc": "<p>The currently enabled clock mode.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_clock_mode", "modulename": "pyspecde", "qualname": "SpectrumCard.set_clock_mode", "type": "function", "doc": "<p>Change the clock mode. See ClockMode and the Spectrum documentation for available modes.</p>\n", "parameters": ["self", "mode"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumCard.available_io_modes", "modulename": "pyspecde", "qualname": "SpectrumCard.available_io_modes", "type": "variable", "doc": "<p>For each multipurpose IO line on the card, read the available modes. See IOLineMode and the Spectrum\nDocumentation for all possible available modes and their meanings.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.feature_list", "modulename": "pyspecde", "qualname": "SpectrumCard.feature_list", "type": "variable", "doc": "<p>Get a list of the features of the card. See CardFeature, AdvancedCardFeature and the Spectrum\ndocumentation for more information.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.sample_rate_hz", "modulename": "pyspecde", "qualname": "SpectrumCard.sample_rate_hz", "type": "variable", "doc": "<p>The rate at which samples will be acquired during an acquisition, in Hz.</p>\n"}, {"fullname": "pyspecde.SpectrumCard.set_sample_rate_hz", "modulename": "pyspecde", "qualname": "SpectrumCard.set_sample_rate_hz", "type": "function", "doc": "<p>Change the rate at which samples will be acquired during an acquisition, in Hz.</p>\n", "parameters": ["self", "rate"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub", "modulename": "pyspecde", "qualname": "SpectrumStarHub", "type": "class", "doc": "<p>Composite of SpectrumDevices</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.__init__", "modulename": "pyspecde", "qualname": "SpectrumStarHub.__init__", "type": "function", "doc": "<p>SpectrumStarHub</p>\n\n<p>Class for controlling a StarHub device, for example the Spectrum NetBox. StarHub devices are composites of more\nthan one Spectrum card. Acquisition from the child cards of a StarHub is synchronised, aggregating the channels\nof all child cards. This class enables the control of a StarHub device as if it was a single Spectrum card.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>device_number (int):</strong>  The index of the StarHub to connect to. If only one StarHub is present, set to 0.</li>\n<li><strong>child_cards (Sequence[SpectrumCard]):</strong>  A list of SpectrumCard objects defining the child cards located\nwithin the StarHub, including their IP addresses and/or device numbers.</li>\n<li><strong>master_card_index (int):</strong>  The position within child_cards where the master card (the card which controls the\nclock) is located.</li>\n</ul>\n", "parameters": ["self", "device_number", "child_cards", "master_card_index"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.disconnect", "modulename": "pyspecde", "qualname": "SpectrumStarHub.disconnect", "type": "function", "doc": "<p>Disconnects from each child card and terminates connection to the hub itself.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.reconnect", "modulename": "pyspecde", "qualname": "SpectrumStarHub.reconnect", "type": "function", "doc": "<p>Reconnects to the hub after a disconnect(), and reconnects to each child card.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.status", "modulename": "pyspecde", "qualname": "SpectrumStarHub.status", "type": "variable", "doc": "<p>The statuses of each child card, in a list. See SpectrumCard.status for more information.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>statuses (STAR_HUB_STATUS_TYPE): A list of lists of CardStatus.</p>\n</blockquote>\n"}, {"fullname": "pyspecde.SpectrumStarHub.start_transfer", "modulename": "pyspecde", "qualname": "SpectrumStarHub.start_transfer", "type": "function", "doc": "<p>Start the transfer of samples from the on-device buffer of each child card to its TransferBuffer.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.stop_transfer", "modulename": "pyspecde", "qualname": "SpectrumStarHub.stop_transfer", "type": "function", "doc": "<p>Stop the transfer of samples from each card to its TransferBuffer.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.wait_for_transfer_to_complete", "modulename": "pyspecde", "qualname": "SpectrumStarHub.wait_for_transfer_to_complete", "type": "function", "doc": "<p>Wait for all cards to stop transferring samples to their TransferBuffers.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.connected", "modulename": "pyspecde", "qualname": "SpectrumStarHub.connected", "type": "variable", "doc": "<p>True if a StarHub is connected, False if not.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_triggering_card", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_triggering_card", "type": "function", "doc": "<p>Change the index of the child_card responsible for receiving a trigger. During construction, this is set\nequal to the index of the master card but in some situations it may be necessary to change it.</p>\n", "parameters": ["self", "card_index"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.clock_mode", "modulename": "pyspecde", "qualname": "SpectrumStarHub.clock_mode", "type": "variable", "doc": "<p>The clock mode configured on the master card.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_clock_mode", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_clock_mode", "type": "function", "doc": "<p>Change the clock mode configured on the master card.</p>\n", "parameters": ["self", "mode"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.sample_rate_hz", "modulename": "pyspecde", "qualname": "SpectrumStarHub.sample_rate_hz", "type": "variable", "doc": "<p>The sample rate configured on the master card.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_sample_rate_hz", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_sample_rate_hz", "type": "function", "doc": "<p>Change the sample rate configured on the master card.</p>\n", "parameters": ["self", "rate"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.trigger_sources", "modulename": "pyspecde", "qualname": "SpectrumStarHub.trigger_sources", "type": "variable", "doc": "<p>The trigger sources configured on the triggering card, which by default is the master card.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_trigger_sources", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_trigger_sources", "type": "function", "doc": "<p>Change the trigger sources configured on the triggering card, which by default is the master card.</p>\n", "parameters": ["self", "sources"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.external_trigger_mode", "modulename": "pyspecde", "qualname": "SpectrumStarHub.external_trigger_mode", "type": "variable", "doc": "<p>The trigger mode configured on the triggering card, which by default is the master card.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_external_trigger_mode", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_external_trigger_mode", "type": "function", "doc": "<p>Change the trigger mode configured on the triggering card, which by default is the master card.</p>\n", "parameters": ["self", "mode"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.external_trigger_level_mv", "modulename": "pyspecde", "qualname": "SpectrumStarHub.external_trigger_level_mv", "type": "variable", "doc": "<p>The external trigger level configured on the triggering card, which by default is the master card.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_external_trigger_level_mv", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_external_trigger_level_mv", "type": "function", "doc": "<p>Change the external trigger level configured on the triggering card, which by default is the master card.</p>\n", "parameters": ["self", "level"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.external_trigger_pulse_width_in_samples", "modulename": "pyspecde", "qualname": "SpectrumStarHub.external_trigger_pulse_width_in_samples", "type": "variable", "doc": "<p>The trigger pulse width (samples) configured on the triggering card, which by default is the master card.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_external_trigger_pulse_width_in_samples", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_external_trigger_pulse_width_in_samples", "type": "function", "doc": "<p>Change the trigger pulse width (samples) configured on the triggering card, which by default is the master\ncard.</p>\n", "parameters": ["self", "width"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.apply_channel_enabling", "modulename": "pyspecde", "qualname": "SpectrumStarHub.apply_channel_enabling", "type": "function", "doc": "<p>Apply the enabled channels chosen using set_enable_channels(). This happens automatically and does not\nusually need to be called.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.enabled_channels", "modulename": "pyspecde", "qualname": "SpectrumStarHub.enabled_channels", "type": "variable", "doc": "<p>The currently enabled channel indices, indexed over the whole hub (from 0 to N-1, where N is the total\nnumber of channels available to the hub).</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_enabled_channels", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_enabled_channels", "type": "function", "doc": "<p>Change the currently enabled channel indices, indexed over the whole hub (from 0 to N-1, where N is the total\nnumber of channels available to the hub).</p>\n", "parameters": ["self", "channels_nums"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.transfer_buffers", "modulename": "pyspecde", "qualname": "SpectrumStarHub.transfer_buffers", "type": "variable", "doc": "<p>The TransferBuffers of all of the child cards of the hub.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.define_transfer_buffer", "modulename": "pyspecde", "qualname": "SpectrumStarHub.define_transfer_buffer", "type": "function", "doc": "<p>Create or provide CardToPCDataTransferBuffer objects for receiving acquired samples from the child cards.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>buffer (Optional[CardToPCDataTransferBuffer]):</strong>  A list containing pre-constructed</li>\n<li>CardToPCDataTransferBuffer objects, one for each child card. The size of the buffers should be chosen</li>\n<li>according to the current number of active channels in each card and the acquisition length.</li>\n</ul>\n\n<p>If no buffers are provided, they will be created with the correct size and a board_memory_offset_bytes of 0.</p>\n", "parameters": ["self", "buffer"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.wait_for_acquisition_to_complete", "modulename": "pyspecde", "qualname": "SpectrumStarHub.wait_for_acquisition_to_complete", "type": "function", "doc": "<p>Wait for each card to finish its acquisition.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.get_waveforms", "modulename": "pyspecde", "qualname": "SpectrumStarHub.get_waveforms", "type": "function", "doc": "<p>Get a list of of the most recently transferred waveforms.</p>\n\n<p>This method gets the waveforms from each child card and joins them into a new list, ordered by channel number.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.channels", "modulename": "pyspecde", "qualname": "SpectrumStarHub.channels", "type": "variable", "doc": "<p>A list of all the channels of the child cards of the hub.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.acquisition_length_samples", "modulename": "pyspecde", "qualname": "SpectrumStarHub.acquisition_length_samples", "type": "variable", "doc": "<p>The currently set recording length, which should be the same for all child cards. If different recording\nlengths are set, an exception is raised.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_acquisition_length_samples", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_acquisition_length_samples", "type": "function", "doc": "<p>Set a new recording length for all child cards.</p>\n", "parameters": ["self", "length_in_samples"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.post_trigger_length_samples", "modulename": "pyspecde", "qualname": "SpectrumStarHub.post_trigger_length_samples", "type": "variable", "doc": "<p>The number of samples recorded after a trigger is receive. This should be consistent across all child\ncards. If different values are found across the child cards, an exception is raised.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_post_trigger_length_samples", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_post_trigger_length_samples", "type": "function", "doc": "<p>Set a new post trigger length for all child cards.</p>\n", "parameters": ["self", "length_in_samples"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.acquisition_mode", "modulename": "pyspecde", "qualname": "SpectrumStarHub.acquisition_mode", "type": "variable", "doc": "<p>The acquisition mode, which should be the same for all child cards. If it's not, an exception is raised.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_acquisition_mode", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_acquisition_mode", "type": "function", "doc": "<p>Change the acquisition mode for all child cards.</p>\n", "parameters": ["self", "mode"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.timeout_ms", "modulename": "pyspecde", "qualname": "SpectrumStarHub.timeout_ms", "type": "variable", "doc": "<p>The time for which the card will wait for a trigger to tbe received after an acquisition has started\nbefore returning an error. This should be the same for all child cards. If it's not, an exception is raised.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.set_timeout_ms", "modulename": "pyspecde", "qualname": "SpectrumStarHub.set_timeout_ms", "type": "function", "doc": "<p>Change the timeout value for all child cards.</p>\n", "parameters": ["self", "timeout_ms"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumStarHub.feature_list", "modulename": "pyspecde", "qualname": "SpectrumStarHub.feature_list", "type": "variable", "doc": "<p>Get a list of the features of the child cards. See CardFeature, AdvancedCardFeature and the Spectrum\ndocumentation for more information. The features should be the same across all child cards. If not, an\nexception is raised.</p>\n"}, {"fullname": "pyspecde.SpectrumStarHub.available_io_modes", "modulename": "pyspecde", "qualname": "SpectrumStarHub.available_io_modes", "type": "variable", "doc": "<p>For each multipurpose IO line on the master card, read the available modes. See IOLineMode and the Spectrum\nDocumentation for all possible available modes and their meanings.</p>\n"}, {"fullname": "pyspecde.SpectrumChannel", "modulename": "pyspecde", "qualname": "SpectrumChannel", "type": "class", "doc": "<p>Class for controlling a channel of a spectrum digitizer. Channels are constructed automatically when\na SpectrumDevice is instantiated.</p>\n"}, {"fullname": "pyspecde.SpectrumChannel.__init__", "modulename": "pyspecde", "qualname": "SpectrumChannel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "channel_number", "parent_device"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumChannel.name", "modulename": "pyspecde", "qualname": "SpectrumChannel.name", "type": "variable", "doc": "<p>The identifier assigned by the spectrum drive, formatted as an Enum by the settings package.</p>\n"}, {"fullname": "pyspecde.SpectrumChannel.vertical_range_mv", "modulename": "pyspecde", "qualname": "SpectrumChannel.vertical_range_mv", "type": "variable", "doc": "<p>The currently set input range of the channel in mV.</p>\n"}, {"fullname": "pyspecde.SpectrumChannel.set_vertical_range_mv", "modulename": "pyspecde", "qualname": "SpectrumChannel.set_vertical_range_mv", "type": "function", "doc": "<p>Set the input range of the channel in mV. See Spectrum documentation for valid values.</p>\n", "parameters": ["self", "vertical_range"], "funcdef": "def"}, {"fullname": "pyspecde.SpectrumChannel.vertical_offset_percent", "modulename": "pyspecde", "qualname": "SpectrumChannel.vertical_offset_percent", "type": "variable", "doc": "<p>The currently set input offset of the channel in percent of the vertical range.</p>\n"}, {"fullname": "pyspecde.SpectrumChannel.set_vertical_offset_percent", "modulename": "pyspecde", "qualname": "SpectrumChannel.set_vertical_offset_percent", "type": "function", "doc": "<p>Set the input offset of the channel in percent of the vertical range. See spectrum documentation for valid\nvalues.</p>\n", "parameters": ["self", "offset"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumCard", "modulename": "pyspecde", "qualname": "MockSpectrumCard", "type": "class", "doc": "<p>Abstract superclass which implements methods of the interface common to all Spectrum digitizer devices.</p>\n"}, {"fullname": "pyspecde.MockSpectrumCard.__init__", "modulename": "pyspecde", "qualname": "MockSpectrumCard.__init__", "type": "function", "doc": "<p>MockSpectrumDevice</p>\n\n<p>Overrides methods of SpectrumCard that communicate with hardware with mocked implementations, allowing\nsoftware to be tested without Spectrum hardware connected or drivers installed, e.g. during CI. Also overrides\nmethods used to set up a mock 'on device buffer' attribute into which a mock waveform source will write\nsamples.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>mock_source_frame_rate_hz (float):</strong>  Rate at which waveforms will be generated by the mock source providing data\nto the mock spectrum card.</li>\n<li><strong>num_modules (int):</strong>  The number of internal modules to assign the mock card. Default 2.</li>\n<li><strong>num_channels_per_module (int):</strong>  The number of channels per module. Default 4 (so 8 channels in total).</li>\n</ul>\n", "parameters": ["self", "device_number", "mock_source_frame_rate_hz", "num_modules", "num_channels_per_module"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumCard.set_acquisition_length_samples", "modulename": "pyspecde", "qualname": "MockSpectrumCard.set_acquisition_length_samples", "type": "function", "doc": "<p>Set length of mock recording (per channel). In FIFO mode, this will be quantised to the nearest 8 samples.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>length_in_samples (int):</strong>  Number of samples in each generated mock waveform</li>\n</ul>\n", "parameters": ["self", "length_in_samples"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumCard.set_enabled_channels", "modulename": "pyspecde", "qualname": "MockSpectrumCard.set_enabled_channels", "type": "function", "doc": "<p>Set the channels to enable for the mock acquisition</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>channels_nums (List[int]):</strong>  List of mock channel indices to enable, e.g. [0, 1, 2].</li>\n</ul>\n", "parameters": ["self", "channels_nums"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumCard.define_transfer_buffer", "modulename": "pyspecde", "qualname": "MockSpectrumCard.define_transfer_buffer", "type": "function", "doc": "<p>Creates a TransferBuffer object into which samples from the mock 'on device buffer' will be transferred.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>buffer (Optional[TransferBuffer]):</strong>  A length-1 list containing a CardToPCDataTransferBuffer object. If None\nis provided, a buffer will be instantiated using the currently set acquisition length and the number of\nenabled channels.</li>\n</ul>\n", "parameters": ["self", "buffer"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumCard.start_transfer", "modulename": "pyspecde", "qualname": "MockSpectrumCard.start_transfer", "type": "function", "doc": "<p>Simulates the continuous transfer of samples from the mock 'on device buffer' to the transfer buffer by\npointing the transfer buffer's data buffer attribute to the on device buffer.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumCard.stop_transfer", "modulename": "pyspecde", "qualname": "MockSpectrumCard.stop_transfer", "type": "function", "doc": "<p>Simulates the end of the continuous transfer of samples from the mock 'on device buffer' to the transfer\nbuffer by assigning the transfer bugger to an array of zeros.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumCard.wait_for_transfer_to_complete", "modulename": "pyspecde", "qualname": "MockSpectrumCard.wait_for_transfer_to_complete", "type": "function", "doc": "<p>Blocks until a new mock transfer has been completed (i.e. the contents of the transfer buffer has changed\nsince __init__() or since the last call to wait_for_transfer_to_complete).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumCard.wait_for_acquisition_to_complete", "modulename": "pyspecde", "qualname": "MockSpectrumCard.wait_for_acquisition_to_complete", "type": "function", "doc": "<p>Blocks until a mock acquisition has been completed (i.e. the acquisition thread has shut down) or the request\nhas timed out according to the self.timeout_ms attribute.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumStarHub", "modulename": "pyspecde", "qualname": "MockSpectrumStarHub", "type": "class", "doc": "<p>Composite of SpectrumDevices</p>\n"}, {"fullname": "pyspecde.MockSpectrumStarHub.__init__", "modulename": "pyspecde", "qualname": "MockSpectrumStarHub.__init__", "type": "function", "doc": "<p>MockSpectrumStarHub</p>\n\n<p>Overrides methods of SpectrumStarHub and SpectrumDevice that communicate with hardware with mocked\nimplementations, allowing software to be tested without Spectrum hardware connected or drivers installed,\ne.g. during CI.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>child_cards (Sequence[MockSpectrumCard]):</strong>  A list of MockSpectrumCard objects defining the properties of the\nchild cards located within the mock hub.</li>\n<li><strong>master_card_index (int):</strong>  The position within child_cards where the master card (the card which controls the\nclock) is located.</li>\n</ul>\n", "parameters": ["self", "device_number", "child_cards", "master_card_index"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumStarHub.start_acquisition", "modulename": "pyspecde", "qualname": "MockSpectrumStarHub.start_acquisition", "type": "function", "doc": "<p>Start a mock acquisition</p>\n\n<p>This method overrides SpectrumDevice.start_acquisition. In reality, StarHub's only need to be sent a single\ninstruction to start acquisition, which they automatically relay to their child cards - hence why\nstart_acquisition is implemented in SpectrumDevice (base class to both SpectrumCard and SpectrumStarHub) rather\nthan in SpectrumStarHub. For the mock implementation, each card's acquisition is started individually.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.MockSpectrumStarHub.stop_acquisition", "modulename": "pyspecde", "qualname": "MockSpectrumStarHub.stop_acquisition", "type": "function", "doc": "<p>Stop a mock acquisition</p>\n\n<p>This method overrides SpectrumDevice.stop_acquisition. In reality, StarHub's only need to be sent a single\ninstruction to stop acquisition, which they automatically relay to their child cards - hence why\nstop_acquisition is implemented in SpectrumDevice (base class to both SpectrumCard and SpectrumStarHub) rather\nthan in SpectrumStarHub. For the mock implementation, each card's acquisition is stopped individually.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "pyspecde.settings", "modulename": "pyspecde.settings", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.AcquisitionMode", "modulename": "pyspecde.settings", "qualname": "AcquisitionMode", "type": "class", "doc": "<p>Enum representing the acquisition modes currently support by pyspecde. See Spectrum documentation for more\ninformation about each mode.</p>\n\n<p>SPC_REC_STD_SINGLE: Data acquisition to on-board memory for one single trigger event.\nSPC_REC_FIFO_MULTI: Continuous data acquisition for multiple trigger events.</p>\n"}, {"fullname": "pyspecde.settings.AcquisitionMode.SPC_REC_STD_SINGLE", "modulename": "pyspecde.settings", "qualname": "AcquisitionMode.SPC_REC_STD_SINGLE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.AcquisitionMode.SPC_REC_FIFO_MULTI", "modulename": "pyspecde.settings", "qualname": "AcquisitionMode.SPC_REC_FIFO_MULTI", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ClockMode", "modulename": "pyspecde.settings", "qualname": "ClockMode", "type": "class", "doc": "<p>Enum representing the clock modes currently supported by pyspecde. See Spectrum documentation for more\ninformation about each mode.</p>\n\n<p>SPC_CM_INTPLL: Enables internal PLL with 20 MHz internal reference for sample clock generation.\nSPC_CM_EXTERNAL: Enables external clock input for direct sample clock generation.\nSPC_CM_EXTREFCLOCK: Enables internal PLL with external reference for sample clock generation.</p>\n"}, {"fullname": "pyspecde.settings.ClockMode.SPC_CM_INTPLL", "modulename": "pyspecde.settings", "qualname": "ClockMode.SPC_CM_INTPLL", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ClockMode.SPC_CM_EXTERNAL", "modulename": "pyspecde.settings", "qualname": "ClockMode.SPC_CM_EXTERNAL", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ClockMode.SPC_CM_EXTREFCLOCK", "modulename": "pyspecde.settings", "qualname": "ClockMode.SPC_CM_EXTREFCLOCK", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature", "modulename": "pyspecde.settings", "qualname": "CardFeature", "type": "class", "doc": "<p>Enum representing the possible features of all Spectrum devices. A list of features can be read from a device\nusing the feature_list property. See the Spectrum documentation for descriptions of each of the features.</p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_MULTI", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_MULTI", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_GATE", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_GATE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_DIGITAL", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_DIGITAL", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_TIMESTAMP", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_TIMESTAMP", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUB6_EXTM", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUB6_EXTM", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUB8_EXTM", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUB8_EXTM", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUB4", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUB4", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUB5", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUB5", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUB16_EXTM", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUB16_EXTM", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUB8", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUB8", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUB16", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUB16", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_ABA", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_ABA", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_BASEXIO", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_BASEXIO", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_AMPLIFIER_10V", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_AMPLIFIER_10V", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUBSYSMASTER", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUBSYSMASTER", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_DIFFMODE", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_DIFFMODE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_SEQUENCE", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_SEQUENCE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_AMPMODULE_10V", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_AMPMODULE_10V", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_STARHUBSYSSLAVE", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_STARHUBSYSSLAVE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_NETBOX", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_NETBOX", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_REMOTESERVER", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_REMOTESERVER", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_SCAPP", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_SCAPP", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardFeature.SPCM_FEAT_CUSTOMMOD_MASK", "modulename": "pyspecde.settings", "qualname": "CardFeature.SPCM_FEAT_CUSTOMMOD_MASK", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.AdvancedCardFeature", "modulename": "pyspecde.settings", "qualname": "AdvancedCardFeature", "type": "class", "doc": "<p>Enum representing the possible advanced features of all Spectrum devices. A list of features can be read from a\ndevice using the feature_list property. See the Spectrum documentation for descriptions of each of the features.</p>\n"}, {"fullname": "pyspecde.settings.AdvancedCardFeature.SPCM_FEAT_EXTFW_SEGSTAT", "modulename": "pyspecde.settings", "qualname": "AdvancedCardFeature.SPCM_FEAT_EXTFW_SEGSTAT", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.AdvancedCardFeature.SPCM_FEAT_EXTFW_SEGAVERAGE", "modulename": "pyspecde.settings", "qualname": "AdvancedCardFeature.SPCM_FEAT_EXTFW_SEGAVERAGE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.AdvancedCardFeature.SPCM_FEAT_EXTFW_BOXCAR", "modulename": "pyspecde.settings", "qualname": "AdvancedCardFeature.SPCM_FEAT_EXTFW_BOXCAR", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode", "modulename": "pyspecde.settings", "qualname": "IOLineMode", "type": "class", "doc": "<p>Enum representing the possible modes that a devices multi-purpose I/O line can support. A list of available\nmodes for each I/O line on a device is provided by the devices available_io_modes property. See the Spectrum\ndocumentation for a description of each of the modes.</p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_DISABLE", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_DISABLE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_ASYNCIN", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_ASYNCIN", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_ASYNCOUT", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_ASYNCOUT", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_DIGIN", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_DIGIN", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_TRIGIN", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_TRIGIN", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_DIGOUT", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_DIGOUT", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_TRIGOUT", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_TRIGOUT", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_RUNSTATE", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_RUNSTATE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_ARMSTATE", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_ARMSTATE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.IOLineMode.SPCM_XMODE_CONTOUTMARK", "modulename": "pyspecde.settings", "qualname": "IOLineMode.SPCM_XMODE_CONTOUTMARK", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.TransferBuffer", "modulename": "pyspecde.settings", "qualname": "TransferBuffer", "type": "class", "doc": "<p>A buffer for transferring samples between pyspecde software and a hardware device. See the 'Definition of the\ntransfer buffer' section of the Spectrum documentation for more information. This implementation of the buffer\nsets the notify size equal to the acquisition length.</p>\n"}, {"fullname": "pyspecde.settings.TransferBuffer.__init__", "modulename": "pyspecde.settings", "qualname": "TransferBuffer.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "type", "direction", "board_memory_offset_bytes", "data_buffer"], "funcdef": "def"}, {"fullname": "pyspecde.settings.TransferBuffer.data_buffer_pointer", "modulename": "pyspecde.settings", "qualname": "TransferBuffer.data_buffer_pointer", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.TransferBuffer.data_buffer_length_bytes", "modulename": "pyspecde.settings", "qualname": "TransferBuffer.data_buffer_length_bytes", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.TransferBuffer.notify_size_bytes", "modulename": "pyspecde.settings", "qualname": "TransferBuffer.notify_size_bytes", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CardToPCDataTransferBuffer", "modulename": "pyspecde.settings", "qualname": "CardToPCDataTransferBuffer", "type": "class", "doc": "<p>A TransferBuffer configured for card-to-pc transfer of samples (rather than timestamps or ABA data).</p>\n"}, {"fullname": "pyspecde.settings.CardToPCDataTransferBuffer.__init__", "modulename": "pyspecde.settings", "qualname": "CardToPCDataTransferBuffer.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "size_in_samples", "board_memory_offset_bytes"], "funcdef": "def"}, {"fullname": "pyspecde.settings.TriggerSource", "modulename": "pyspecde.settings", "qualname": "TriggerSource", "type": "class", "doc": "<p>An Enum representing the size possible trigger sources.</p>\n\n<p>SPC_TMASK_SOFTWARE: Enables the software trigger for the OR mask. The card will trigger immediately after start.\nSPC_TMASK_EXT0: Enables the external (analog) trigger 0 for the OR mask.\nSPC_TMASK_EXT1: Enables the X1 (logic) trigger for the OR mask.\nSPC_TMASK_EXT2: Enables the X2 (logic) trigger for the OR mask.\nSPC_TMASK_EXT3: Enables the X3 (logic) trigger for the OR mask.\nSPC_TMASK_NONE: No trigger source selected.</p>\n"}, {"fullname": "pyspecde.settings.TriggerSource.SPC_TMASK_SOFTWARE", "modulename": "pyspecde.settings", "qualname": "TriggerSource.SPC_TMASK_SOFTWARE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.TriggerSource.SPC_TMASK_EXT0", "modulename": "pyspecde.settings", "qualname": "TriggerSource.SPC_TMASK_EXT0", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.TriggerSource.SPC_TMASK_EXT1", "modulename": "pyspecde.settings", "qualname": "TriggerSource.SPC_TMASK_EXT1", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.TriggerSource.SPC_TMASK_EXT2", "modulename": "pyspecde.settings", "qualname": "TriggerSource.SPC_TMASK_EXT2", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.TriggerSource.SPC_TMASK_EXT3", "modulename": "pyspecde.settings", "qualname": "TriggerSource.SPC_TMASK_EXT3", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.TriggerSource.SPC_TMASK_NONE", "modulename": "pyspecde.settings", "qualname": "TriggerSource.SPC_TMASK_NONE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode", "type": "class", "doc": "<p>An Enum representing the supported trigger modes. See the Spectrum documentation more more Information.</p>\n\n<p>SPC_TM_NONE: Channel is not used for trigger detection.\nSPC_TM_POS: Trigger detection for positive edges (crossing level 0 from below to above).\nSPC_TM_NEG: Trigger detection for negative edges (crossing level 0 from above to below).\nSPC_TM_BOTH: Trigger detection for positive and negative edges (any crossing of level 0).\nSPC_TM_HIGH: Trigger detection for HIGH levels (signal above level 0)\nSPC_TM_LOW: Trigger detection for LOW levels (signal below level 0)\nSPC_TM_PW_GREATER: Sets the trigger mode for external trigger to detect pulses that are longer than the pulse width\n    chosen using the devices set_external_trigger_pulse_width_in_samples() method. Can only be used in combination\n    with one of the above modes.\nSPC_TM_PW_SMALLER: Sets the trigger mode for external trigger to detect pulses that are shorter than the pulse width\n    chosen using the devices set_external_trigger_pulse_width_in_samples() method. Can only be used in combination\n    with one of the above modes.</p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode.SPC_TM_NONE", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode.SPC_TM_NONE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode.SPC_TM_POS", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode.SPC_TM_POS", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode.SPC_TM_NEG", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode.SPC_TM_NEG", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode.SPC_TM_BOTH", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode.SPC_TM_BOTH", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode.SPC_TM_HIGH", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode.SPC_TM_HIGH", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode.SPC_TM_LOW", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode.SPC_TM_LOW", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode.SPC_TM_PW_GREATER", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode.SPC_TM_PW_GREATER", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.ExternalTriggerMode.SPC_TM_PW_SMALLER", "modulename": "pyspecde.settings", "qualname": "ExternalTriggerMode.SPC_TM_PW_SMALLER", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.CARD_STATUS_TYPE", "modulename": "pyspecde.settings", "qualname": "CARD_STATUS_TYPE", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "pyspecde.settings.STAR_HUB_STATUS_TYPE", "modulename": "pyspecde.settings", "qualname": "STAR_HUB_STATUS_TYPE", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "pyspecde.settings.StatusCode", "modulename": "pyspecde.settings", "qualname": "StatusCode", "type": "class", "doc": "<p>An enumeration.</p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_NONE", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_NONE", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_CARD_PRETRIGGER", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_CARD_PRETRIGGER", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_CARD_TRIGGER", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_CARD_TRIGGER", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_CARD_READY", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_CARD_READY", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_CARD_SEGMENT_PRETRG", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_CARD_SEGMENT_PRETRG", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_DATA_BLOCKREADY", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_DATA_BLOCKREADY", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_DATA_END", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_DATA_END", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_DATA_OVERRUN", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_DATA_OVERRUN", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_DATA_ERROR", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_DATA_ERROR", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_EXTRA_BLOCKREADY", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_EXTRA_BLOCKREADY", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_EXTRA_END", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_EXTRA_END", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_EXTRA_OVERRUN", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_EXTRA_OVERRUN", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "pyspecde.settings.StatusCode.M2STAT_EXTRA_ERROR", "modulename": "pyspecde.settings", "qualname": "StatusCode.M2STAT_EXTRA_ERROR", "type": "variable", "doc": "<p></p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.addField("qualname");
            this.addField("fullname");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();